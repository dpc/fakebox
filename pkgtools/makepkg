#!/bin/bash
#
# makepkg - Lintrack package build tool
# stripped down, cleaned up and feature enhanced version for Lintrack
#
# Copyright (C):
# 	2002-2004 by Judd Vinet <jvinet@zeroflux.org> (Arch Linux)
# 	2005 by Dawid Ciezarkiewicz <dpc@asn.pl> (Lintrack)
# 	2005-2007 by Pawel Foremski <pjf@asn.pl> (Lintrack)
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.	See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307, USA.
#

myver='0.21'
startdir="`pwd`"
PKGDEST=${PKGDEST:-$startdir}

### SUBROUTINES ###
plain() { echo "  $1" >&2; }
msg() { echo "==> $1" >&2; }
warning() { echo "==> WARNING: $1" >&2; }
error() { echo "==> ERROR: $1" >&2; msg "Aborting..."; exit ${2:-1}; }

strip_url() { echo $1 | sed 's|^.*://.*/||g'; }

function usage()
{
	cat <<-EOF
	Lintrack package builder, version $myver
	Usage: makepkg [options]

	Options:
	  -e, --noextract  Do not extract source files (use existing src/ dir)
	  -d, --delsrc     Delete existing src/ dir
	  -o, --nobuild    Download and extract files only
	  -P, --pack       Just make a package of ./pkg/ directory
	  -F <fixrel>      Make a fixrel>1 package of ./pkg/ directory and
	                   FIX-<fixrel> script in main package directory
	                   Hint: you may use <fixrel>=2-big, etc., too
	  -p <buildscript> Use an alternate build script (instead of PKGBUILD)
	  -w <destdir>     Write package to <destdir> (instead of PKGDEST)
	  -h, --help       This help
	  -v, --version    Show version information and exit
	
	  If -p is not specified, makepkg will look for a PKGBUILD
	  file in the current directory.
	EOF
}

function version()
{
	cat <<-EOF
	makepkg (Lintrack) $myver
	
	Copyright (C) 2005-2007 by Pawel Foremski <pjf@asn.pl> (Lintrack)
	Copyright (C) 2005 by Dawid Ciezarkiewicz <dpc@asn.pl> (Lintrack)
	Copyright (C) 2002-2004 by Judd Vinet <jvinet@zeroflux.org> (Arch Linux)
	
	This is free software; see the source for copying conditions. There is NO
	warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	EOF
}

# some useful functions imported from dqd installer
function name_base() { echo $1 | sed -e 's/\/$//' -e 's/.*\///'; }
function name_dir() { echo $1 | sed -e 's/\/$//' -e 's/\/[^\/]*$//'; }

function realpath()
{
	# this parses '~' symbols
	eval "path=\"\`echo $1\`\""

	if [ "${path:0:1}" = '/' ]; then
			curdir=
	else
			curdir="`pwd`"
	fi

	for part in `echo "$path" | sed -e 's/\// /g'`; do
		if [ "$part" = '.' ]; then
			continue
		elif [ "$part" = '..' ]; then
			curdir="`name_dir $curdir`"
		elif [ -n "$part" ]; then
			curdir="$curdir/$part"
		fi
	done

	if [ -z "$curdir" ]; then
		echo '/'
	else
		echo $curdir
	fi
}

# commonly used operations
function patches()
{
	if [ "$NOEXTRACT" = "1" ]; then
		warning "Skipping source patchning - using existing src/ tree"
		return
	fi

	for file in ${1:-$startdir/patches/*.diff.bz2}; do
		msg "patching with `basename $file`"
		bunzip2 -c $file | patch -p1 || return 1
	done
}

function files()
{
	cp -a ${1:-$startdir/files/*} ${2:-$startdir/pkg/} || return 1
}

## builds a package from current dir
function build_package()
{
	local pkgdst files perm ppath pmode puser pgroup file

	case "$1" in
		"big")
			msg "Building big package"; suffix="-big" ;;
		"small")
			msg "Building a stripped-down version of package"; suffix="" ;;
		*)
			warning "Don't know how to build \"$1\" package"; return ;;
	esac

	msg "  Generating .FILELIST file..."
	tar cvf /dev/null * | sort > .FILELIST

	# size and time changes, so do it here
	msg "  Generating .PKGINFO file..."
	(
		LC_ALL=; LANG=;

		echo "# Generated by makepkg $myver (Lintrack)"
		echo "# `date`"
		echo "pkgname=\"$pkgname\""
		echo "pkgver=\"$pkgver-$pkgrel${suffix}\""
		echo "builddate=\"`date -u '+%a %b %e %H:%M:%S %Y'`\""
		echo "packager=\"${PACKAGER:-Lintrack (http://www.lintrack.org/)}\""
		echo "size=\"`du -cb . | tail -n 1 | awk '{print \$1}'`\""

		[ -n "$CARCH" ] && echo "arch=\"$CARCH\""
	) > .PKGINFO

	msg "  Compressing..."
	pkgdst="$PKGDEST/$pkgname-$pkgver-$pkgrel-1${suffix}.pkg.tar"
	files="* .PKGINFO .FILELIST"
	[ -f .INSTALL ] && files="$files .INSTALL"

	#
	# Below we implement a flexible way to define final file permissions and ownership by passing us
	# the $perms array of which each element is in the following format: 'path mode user group'
	#
	# Implementation is hackish, but this is caused by no option/way in GNU tar to specify a list
	# for file permissions and ownership.
	#

	# tar all files except listed ones, as root:root
	for perm in "${perms[@]}"; do
		set $perm
		echo "${1%%/}"
		[ -d "$1" ] && echo "${1%%/}/*"
	done \
		| tr ' ' '\n' \
		| tar -c --owner 0 --group 0 -f "$pkgdst" -X - $files \
		2> /dev/null

	# now add the rest with requested perms
	for perm in "${perms[@]}"; do
		set $perm
		ppath="$1"; pmode="$2"; puser="$3"; pgroup="$4"
		tar -r --mode "$pmode" --owner "$puser" --group "$pgroup" -f "$pkgdst" $ppath
	done

	# finally, gzip
	gzip -9f "$pkgdst"
}


### MAIN ###
# options
NOEXTRACT=0
NOBUILD=0
BUILDSCRIPT="./PKGBUILD"
DELSRC=0
JUSTPACK=0
FIXREL=1

ARGLIST=$@
while [ "$#" -ne "0" ]; do
	case $1 in
		--delsrc)    DELSRC=1 ;;
		--noextract) NOEXTRACT=1 ;;
		--nobuild)   NOBUILD=1 ;;
		--pack)      JUSTPACK=1 ;;
		--help)      usage; exit 0 ;;
		--version)   version; exit 0 ;;
		--*)         usage; exit 1 ;;
		-*)
			while getopts "dehoPp:w:vF:-" opt; do
				case $opt in
					d) DELSRC=1 ;;
					e) NOEXTRACT=1 ;;
					h) usage; exit 0 ;;
					v) version; exit 0 ;;
					o) NOBUILD=1 ;;
					p) BUILDSCRIPT=$OPTARG ;;
					P) JUSTPACK=1 ;;
					w) PKGDEST=$OPTARG ;;
					F) FIXREL=$OPTARG ;;
					-) OPTIND=0; break ;;
					*) usage; exit 1 ;;
				esac
			done
			;;
		*) true ;;
	esac
	shift
done

# convert a (possibly) relative path to absolute
PKGDEST="`realpath $PKGDEST`"
mkdir -p $PKGDEST

# unset special variables
unset pkgname pkgver pkgrel md5sums source install build smalldel perms
umask 0022

### prepare to build
[ ! -f $BUILDSCRIPT ] && error "$BUILDSCRIPT does not exist."
source $BUILDSCRIPT

[ `echo $pkgver | grep '-'` ] && error "pkgver is not allowed to contain hyphens."
[ `echo $pkgrel | grep '-'` ] && error "pkgrel is not allowed to contain hyphens."

msg "Making package: $pkgname (`date`)"
cd $startdir

# handle special cases
if [ "$JUSTPACK" = "1" ]; then
	cd pkg/
	build_package small
	msg "Done"
	exit 0
elif [ "$FIXREL" != "1" ]; then
	msg "Creating a fixrel package..."
	cd pkg/

	files="*"
	[ -f ../FIX-$FIXREL ] && {
		msg "  Copying FIX-$FIXREL script"
		cp ../FIX-$FIXREL .FIX
		files="$files .FIX"
	}

	msg "  Compressing..."
	tar -cP --owner 0 --group 0 $files | gzip -9 \
		> "$PKGDEST/$pkgname-$pkgver-$pkgrel-$FIXREL.pkg.tar.gz"

	msg "Done"
	exit 0
fi

# retrieve sources
msg "Retrieving sources..."
mkdir -p $PKGDW
cd $PKGDW

for netfile in ${source[@]}; do
	file=`strip_url $netfile`

	if [ -f $file ]; then
		msg "    Found $file in sources dir"
	else
		[ -z "$FTPAGENT" ] && error "FTPAGENT is not configured."
		ftpclient=`echo $FTPAGENT | awk {'print $1'}`
		[ -z "`which $ftpclient 2> /dev/null`" ] && error "ftpclient `basename $ftpclient` is not installed."

		proto=`echo $netfile | sed 's|://.*||'`
		[ "$proto" != "ftp" -a "$proto" != "http" -a "$proto" != "https" ] && \
			error "$netfile was not found in the build directory and is not a proper URL."

		msg "    Downloading $file"
		$FTPAGENT $netfile 2>&1
		[ ! -f $file ] && error "Failed to download $file"
	fi
done

if [ "$DELSRC" = "1" ]; then
	warning "Deleting existing src/ dir"
	rm -fr $startdir/src
fi

mkdir -p $startdir/src

if [ "$NOEXTRACT" = "1" ]; then
	warning "Skipping source extraction -- using existing src/ dir"
	warning "Skipping source integrity checks -- using existing src/ dir"
else
	# MD5 validation
	if [ ${#md5sums[@]} -ne ${#source[@]} ]; then
		error "MD5 sums are missing or incomplete. Cannot verify source integrity."
	elif [ `type -p md5sum` ]; then
		msg "Validating source files with MD5 sums"
		errors=0
		idx=0
		for netfile in ${source[@]}; do
			file=`strip_url $netfile`
			echo -n "    $file ... "
			echo "${md5sums[$idx]}  $file" | md5sum -c - >/dev/null
			if [ $? -ne 0 ]; then
				echo "FAILED"
				errors=1
			else
				echo "Passed"
			fi
			let idx++
		done

		[ $errors -gt 0 ] && error "One or more files did not pass the validity check!"
	else
		warning "The md5sum program is missing. Cannot verify source files!"
		sleep 1
	fi

	msg "Extracting sources..."
	cd $startdir/src

	for netfile in ${source[@]}; do
		unziphack=0
		file=`strip_url $netfile`
		unset cmd
		case $file in
			*.tar.gz|*.tar.Z|*.tgz)
			        cmd="tar --use-compress-program=gzip -xf $PKGDW/$file" ;;
			*.tar.bz2)
			        cmd="tar --use-compress-program=bzip2 -xf $PKGDW/$file" ;;
			*.tar)  cmd="tar -xf $PKGDW/$file" ;;
			*.zip)  unziphack=1; cmd="unzip -qqo $PKGDW/$file" ;;
			*.gz)   cmd="zcat $PKGDW/$file > ${file%.gz}" ;;
			*.bz2)  cmd="bzcat $PKGDW/$file > ${file%.bz2}" ;;
			*)      cmd="cp $PKGDW/$file ${file}" ;;
		esac

		if [ "$cmd" != "" ]; then
			msg "    $cmd"
			$cmd || {
				# unzip will return a 1 as a warning, it is not an error
				[ "$unziphack" != "1" -o $? -ne 1 ] && error "Failed to extract $file"
			}
		fi
	done
fi

# check for existing pkg directory
[ -d $startdir/pkg ] && { msg "Removing existing pkg/ directory..."; rm -rf $startdir/pkg; }
mkdir -p $startdir/pkg

[ "$NOBUILD" = "1" ] && { msg "Sources are ready."; exit 0; }

### build
msg "Starting build()..."
cd $startdir/src
build 2>&1
[ $? -gt 0 ] && error "Build failed" 2

### let's package it
cd $startdir/pkg

# check for an install script
[ -f ../INSTALL ] && { msg "Copying install script..."; cp ../INSTALL .INSTALL; }

### do tasks for big and small packages
msg "Fixing permissions"
chmod -R u+w .

if [ -d usr/share/man ]; then
	msg "Moving usr/share/man files to usr/man"
	mkdir -p usr/man
	cp -a usr/share/man/* usr/man/
	rm -rf usr/share/man
fi

msg "Compressing man pages..."
find ./{usr{,/local,/share},opt/*}/man -type f 2>/dev/null | while read i ; do
	ext="${i##*.}"
	fn="${i##*/}"

	if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
		# update symlinks to this manpage
		find ./{usr{,/local,/share},opt/*}/man -lname "$fn" 2> /dev/null | while read ln ; do
			rm -f "$ln"
			ln -sf "${fn}.gz" "${ln}.gz"
		done
		# compress the original
		gzip -9 "$i"
	fi
done

# remove empty directories, if needed
[ -d usr/share ] && [ -z "`ls -1 usr/share`" ] && rm -r usr/share
[ -d usr/lib ] && [ -z "`ls -1 usr/lib`" ] && rm -r usr/lib

msg "Removing CVS and .svn dirs..."
find . -type d -name "CVS" -exec rm -rf {} \; 2> /dev/null
find . -type d -name ".svn" -exec rm -rf {} \; 2> /dev/null

### build big package
build_package big

### build normal package
msg "Removing unnecessary files"
rm -rf usr/info usr/share/info
rm -rf usr/doc usr/share/doc
rm -rf usr/docs usr/share/docs
rm -rf usr/share/locale
rm -fr usr/man
rm -rf usr/lib/pkgconfig
rm -fr usr/include

msg "Removing static libraries"
find -name '*.a' -exec rm {} \;

# remove empty dir, if needed
[ -d usr/lib ] && [ -z "`ls -1 usr/lib`" ] && rm -r usr/lib

msg "Stripping debugging symbols from kernel modules..."
find ./lib/modules -type f -name "*.o" -or -name "*.ko" \
	-exec strip -g '{}' \; 2>&1 \
	| grep -v "No such file" | grep -v "format not recognized"

msg "Stripping debugging symbols from libraries..."
find ./{,usr,usr/local,opt/*}/lib -type f \
	-not -name "*.dll" -not -name "*.exe" -not -name "*.o" -not -name "*.ko" \
	-exec strip -s '{}' \; 2>&1 \
	| grep -v "No such file" | grep -v "format not recognized"

msg "Stripping symbols from binaries..."
find ./{,usr,usr/local,opt/*}/{bin,sbin} -type f -not -name "*.dll" -not -name "*.exe" \
	-exec strip -s '{}' \; 2>&1 \
	| grep -v "No such file" | grep -v "format not recognized"

# remove requested files and dirs
for delme in "${smalldel[@]}"; do
	if echo "$delme" | egrep -q '^/'; then
		warning "Not deleting '$delme', as it's given as an absolute path and can harm your system"
		continue
	fi
	msg "Removing $delme"
	rm -fr $delme
done

build_package small

### DONE
cd $startdir

msg "Finished making: $pkgname (`date`)"

exit 0

# vim: textwidth=100
